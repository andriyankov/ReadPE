Библиотеку разбиваю на две части: 

1. первая – та что, предоставляет интерфейс пользователю
2. вторая – что его реализует.

Поскольку элементы библиотеки обычно очень сильно связаны между собой, предоставляю пользователю один файл `my_lib/include.hpp`, содержащий весь необходимый пользователю интерфейс, и `my_lib/implementation.hpp`, содержащий весь код реализации.
Поскольку библиотека – код, который очень редко изменяется, то она – главный кандидат на включение в precompiled header.

Пользователь в `stdafx.h` (`precompiled.hpp`) пишет:
```
#include <my_lib/include.hpp>
```

А в `stdafx.cpp` (`precompiled.cpp`) добавляет:
```
#include <my_lib/implementation.hpp>
```

Таким образом, вся библиотека собирается только тогда, когда изменяется что-нибудь в `precompiled.hpp`. А это, конечно, очень редкое явление.

В) Естественно, `my_lib/include.hpp` реализуется примерно так:
```
#include <…STL…>
#include <my_lib/interface/class1.hpp>
#include <my_lib/interface/class2.hpp>
```

И `my_lib/implementation.hpp`:
```
#include <my_lib/include.hpp> // хотя это можно убрать
#include <my_lib/implementation/class1.hpp>
#include <my_lib/implementation/class2.hpp>
```

Достоинства:

* Очень прост в подключении пользователю
* реализации компилируется отдельно от интерфейсной части библиотеки
* Не требует отдельных проектов (систем сборок) 

Буду рад, если данный подход Вам подойдет…
