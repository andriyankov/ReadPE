Б) Библиотеку разбиваю на две части: первая – та что, предоставляет интерфейс пользователю, вторая – что его реализует. Поскольку элементы библиотеки обычно очень сильно связаны между собой, предоставляю пользователю один файл my_lib/include.hpp, содержащий весь необходимый пользователю интерфейс, и my_lib/implementation.hpp, содержащий весь код реализации.
Поскольку библиотека – код, который очень редко изменяется, то она – главный кандидат на включение в precompiled header.

Пользователь в stdafx.h (precompiled.hpp) пишет:
#include <my_lib/include.hpp>

А в stdafx.cpp (precompiled.cpp) добавляет:
#include <my_lib/implementation.hpp>

Таким образом, вся библиотека собирается только тогда, когда изменяется что-нибудь в precompiled.hpp. А это, конечно, очень редкое явление.

В) Естественно, my_lib/include.hpp реализуется примерно так:
#include <…STL…>
#include <my_lib/interface/class1.hpp>
#include <my_lib/interface/class2.hpp>

И my_lib/implementation.hpp:
#include <my_lib/include.hpp> // хотя это можно убрать
#include <my_lib/implementation/class1.hpp>
#include <my_lib/implementation/class2.hpp>

Достоинства:
А) Очень прост в подключении пользователю
Б) реализации компилируется отдельно от интерфейсной части библиотеки
Б) Не требует отдельных проектов (систем сборок) 

Буду рад, если данный подход Вам подойдет…
