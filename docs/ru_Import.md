# Вместо предисловия

Это документ будет меняться в будущем. Связано это с тем, что формат импорта очень сложен и сразу понять как и что на самом деле не представляется возможным! Это вызвано историческими причинами при развитии системного загрузчика.

Я буду благодарен любым дополнительным сведениям, замечаниям и комментариям. Пишите и не стесняясь!

# Терминология

- `RVA` - Relative Virtual Address. Смещение внутри загруженного модуля в виртуальное адресное пространство относительно адреса загрузки этого модуля
- `IAT` - Import Address Table. Таблица импортируемых адресов.
- `INT` - Import Names or Lookup Table. Таблица импортируемых имен

# Как импортируются функции из других исполныемых функций?

## 1. Массив описателей импортируемых модулей

Каждый импортируемый модуль описывается структурой `IMAGE_IMPORT_DESCRIPTOR`. Добраться до массива нам позволит 2 экземпляр массива из объектов структуры `IMAGE_DATA_DIRECTORY`, который расположен в заголовке `IMAGE_OPTIONAL_HEADER`. Второй элемент `IMAGE_DATA_DIRECTORY` содержит поле `VirtualAddress` указывающее на массив `IMAGE_IMPORT_DESCRIPTOR`. Массив завершается "нулевой" структурой.

## 2. Краткие сведения про IMAGE_IMAGE_IMPORT_DESCRIPTOR

Содержит пять полей типа `uint32_t`:

- `OriginFirstThunk` - Указывает на `INT`
- `TimeDateStamp` - Поле используетя для определения привязанности модуля и типа привязки
- `ForwarderChain` - Может быть задано в `-1` чтоб показать, что нет перенаправлений
- `Name` - Указывает на строку с назаванием импортируемого модуля
- `FirstThunk` - Указывает на `IAT`

## 3. Тип привязки

Тип привязанного импорта определяется на основе анализа поля `TimeDateStamp` и бывает двух видов:

- `Новый`, `New bound import` - если поле равно `-1`
- `Старый`. `Old bound import` - когда поле больше 0 и при этом не равно `-1`
- Нет привязанного импорта, если в поле задан 0

## 3. Название импортируемого поля

В поле `IMAGE_DATA_DIRECTORY.Name` содержится RVA на строку, которая и является именем импортируемого модуля. Строка является null-терминированной.

## 4. IMAGE_IMPORT_DESCRIPTOR.OriginFirstThunk

Указывает на `INT`. Таблицу благодаря, которой системный загрузчик понимает какая именно функция импортируется. Таблица состоит из массива объектов структуры IMAGE_THUNK_DATA.

## 5. IMAGE_IMPORT_DESCRIPTOR.FirstThunk

Указывает на `IAT`. Когда мы в коде вызываем импортируемую функцию, примерно так:

0040103A   CALL DWORD PTR [0x40207A]   USER32.MessageBoxA
00401042   CALL DWORD PTR [0x40205C]   KERNEL32.ExitProcess

То эти самые адреса `0x40207A` и `0x40205C` находятся в `IAT`. Именно эту таблицу во время загрузки модуля системный загручик перезаписывает теми адресами функций из подгружаемых импортируемых модулей.

## 6. Импортирование по ординалу или имени

`IMAGE_IMAGE_THUNK_DATA` это `union`, т.е. то место на которое он указывает может интерпретироваться по разному:
- Ординал
- Адрес
- Указатель на массив из `IMAGE_IMPORT_BY_NAME`
- Указатель на функцию

### 6.1. Импорт по ординалу

- Самый старший разряд поля `IMAGE_IMAGE_THUNK_DATA` не нулевой
- Младшие от страшего разряда являются `RVA` на импортируему функцию

```C++
uint32_t rvaOfImportedFunc = 0;
bool byOrdinal = (thunkData.u1.Ordinal & 0x80000000) > 0;
if (byOrdinal) {
  rvaOfImportedFunc = thunkData.u1.Function & 0x7FFFFFFF;
}
```

### 6.2. Импорт по имени

- Самый старший разряд поля `IMAGE_IMAGE_THUNK_DATA` в нуле
- Тогда поле указывает на массив `IMAGE_IMPORT_BY_NAME`

```C++
IMAGE_IMPORT_BY_NAME* hintAndNames = thunkData.u1.AddressOfData + ModuleBaseAddress;
bool byName = (thunkData.u1.Ordinal & 0x80000000) == 0;
if (byName) {
  while (hintAndNames > 0) {
    uint16_t hint = hintAndNames.hint;
    uint8_t* name = ModuleBaseAddress + hintAndNames.Name;
  }
}
```
